\documentclass[a4paper,11pt]{article}
\usepackage[a4paper, margin=8em]{geometry}

% usa i pacchetti per la scrittura in italiano
\usepackage[french,italian]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\frenchspacing 

% usa i pacchetti per la formattazione matematica
\usepackage{amsmath, amssymb, amsthm, amsfonts}

% usa altri pacchetti
\usepackage{gensymb}
\usepackage{hyperref}
\usepackage{standalone}

% imposta il titolo
\title{Appunti Progettazione Web}
\author{Luca Seggiani}
\date{2024}

% imposta lo stile
% usa helvetica
\usepackage[scaled]{helvet}
% usa palatino
\usepackage{palatino}
% usa un font monospazio guardabile
\usepackage{lmodern}

\renewcommand{\rmdefault}{ppl}
\renewcommand{\sfdefault}{phv}
\renewcommand{\ttdefault}{lmtt}

% disponi il titolo
\makeatletter
\renewcommand{\maketitle} {
	\begin{center} 
		\begin{minipage}[t]{.8\textwidth}
			\textsf{\huge\bfseries \@title} 
		\end{minipage}%
		\begin{minipage}[t]{.2\textwidth}
			\raggedleft \vspace{-1.65em}
			\textsf{\small \@author} \vfill
			\textsf{\small \@date}
		\end{minipage}
		\par
	\end{center}

	\thispagestyle{empty}
	\pagestyle{fancy}
}
\makeatother

% disponi teoremi
\usepackage{tcolorbox}
\newtcolorbox[auto counter, number within=section]{theorem}[2][]{%
	colback=blue!10, 
	colframe=blue!40!black, 
	sharp corners=northwest,
	fonttitle=\sffamily\bfseries, 
	title=Teorema~\thetcbcounter: #2, 
	#1
}

% disponi definizioni
\newtcolorbox[auto counter, number within=section]{definition}[2][]{%
	colback=red!10,
	colframe=red!40!black,
	sharp corners=northwest,
	fonttitle=\sffamily\bfseries,
	title=Definizione~\thetcbcounter: #2,
	#1
}

% disponi codice
\usepackage{listings}
\usepackage[table]{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{codestyle}{
		backgroundcolor=\color{black!5}, 
		commentstyle=\color{codegreen},
		keywordstyle=\bfseries\color{magenta},
		numberstyle=\sffamily\tiny\color{black!60},
		stringstyle=\color{green!50!black},
		basicstyle=\ttfamily\footnotesize,
		breakatwhitespace=false,         
		breaklines=true,                 
		captionpos=b,                    
		keepspaces=true,                 
		numbers=left,                    
		numbersep=5pt,                  
		showspaces=false,                
		showstringspaces=false,
		showtabs=false,                  
		tabsize=2
}

\lstdefinestyle{shellstyle}{
		backgroundcolor=\color{black!5}, 
		basicstyle=\ttfamily\footnotesize\color{black}, 
		commentstyle=\color{black}, 
		keywordstyle=\color{black},
		numberstyle=\color{black!5},
		stringstyle=\color{black}, 
		showspaces=false,
		showstringspaces=false, 
		showtabs=false, 
		tabsize=2, 
		numbers=none, 
		breaklines=true
}

\lstdefinelanguage{css}{
  keywords={text-shadow, text-direction, background-attachement, background-size, font, font-family, font-size, font-style, font-weight, @font-face, letter-spacing, line-height, text-align, text-decoration, text-indent, background, background-color, background-image, background-position, background-repeat, box-shadow, color, opacity, border, border-color, border-width, border-style, border-top, border-left, border-right, border-bottom, border-image, border-radius, padding, padding-bottom, padding-left, padding-right, padding-bottom, margin, margin-bottom, margin-left, margin-right, margin-bottom, height, max-height, min-height, width, max-width, min-width, bottom, left, right, top, clear, display, float, overflow, position, visibility, z-index, list-style, list-style-image, list-style-type, animation, filter, perspective, transform, transition ,a, link, visited, focus, hover, active, checked, first-letter, first-line, before, after, cursor, first-child, font-style,color,background-image:,margin,padding,font,weight,display,position,top,left,right,bottom,list,style,border,size,white,space,min,width, transition:, transform:, transition-property, transition-duration, transition-timing-function},	
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]',
  morestring=[b]",
  alsoletter={:},
  alsodigit={-},
	literate=%
    {:}{{\textcolor{black}{:}}}1,  % Treat ':' as a regular symbol, not part of a keyword
}

\lstdefinelanguage{javascript}{
	keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
	keywordstyle=\color{blue}\bfseries,
	ndkeywords={class, export, boolean, throw, implements, import, this},
	ndkeywordstyle=\color{darkgray}\bfseries,
	identifierstyle=\color{black},
	sensitive=false,
	comment=[l]{//},
	morecomment=[s]{/*}{*/},
	commentstyle=\color{purple}\ttfamily,
	stringstyle=\color{red}\ttfamily,
	morestring=[b]',
	morestring=[b]"
}

% disponi sezioni
\usepackage{titlesec}

\titleformat{\section}
	{\sffamily\Large\bfseries} 
	{\thesection}{1em}{} 
\titleformat{\subsection}
	{\sffamily\large\bfseries}   
	{\thesubsection}{1em}{} 
\titleformat{\subsubsection}
	{\sffamily\normalsize\bfseries} 
	{\thesubsubsection}{1em}{}

% disponi alberi
\usepackage{forest}

\forestset{
	rectstyle/.style={
		for tree={rectangle,draw,font=\large\sffamily}
	},
	roundstyle/.style={
		for tree={circle,draw,font=\large}
	}
}

% disponi numeri di pagina
\usepackage{fancyhdr}
\fancyhf{} 
\fancyfoot[L]{\sffamily{\thepage}}

\makeatletter
\fancyhead[L]{\raisebox{1ex}[0pt][0pt]{\sffamily{\@title \ \@date}}} 
\fancyhead[R]{\raisebox{1ex}[0pt][0pt]{\sffamily{\@author}}}
\makeatother

\begin{document}
% sezione (data)
\section{Lezione del 07-10-24}

% stili pagina
\thispagestyle{empty}
\pagestyle{fancy}

\lstset{language=css, style=codestyle}

% testo
\subsection{CSS}
I Cascading Style Sheets (CSS) sono uno standard per la descrizione della presentazione degli elementi HTML.
In CSS, possiamo assegnare propietà come:
\begin{itemize}
	\item Font;
	\item Colori;
	\item Dimensioni degli elementi;
	\item Posizioni degli elementi;
	\item Bordi;
	\item Immagini di sfondo;
	\item ...
\end{itemize}

In generale, il CSS è un linguaggio a sé stante.
Si può aggiungere del CSS direttamente ad un elemento HTML attraverso l'attributo \lstinline|style|, all'interno dell'intestazione \lstinline|<head>|, o, più comunemente, in un file separato che contiene solo codice CSS.

\subsubsection{Vantaggi del CSS}
Ci sono diversi vantaggi all'uso del CSS:
\begin{itemize}
	\item Il grado di controllo della formattazione in CSS è significativamente migliore di quello fornito da HTML;
	\item I siti web diventano più facili da mantenere quando tutta la formattazione è essere inserita all'interno di uno, o una piccola quantità, di file CSS;
	\item Si ottiene più facilmente uno stile grafico consistente fra pagine;
	\item I siti basati sul CSS sono più accessibili, in quanto l'HTML non deve preoccuparsi della presentazione grafica;
	\item Un sito creato con del CSS serializzato sarà anche più facile da scaricare in quanto ogni pagina conterrà meno codice (basta scaricare il CSS una volta sola);
	\item Col CSS si può adattare una pagina a più formati;
\end{itemize}

Detto questo, ci sono anche varie difficoltà associate al fatto che il CSS non è stato pensato come una lingua per il layout, ergo è complicato gestire elementi fluttuanti, posizioni relative, gestione delle altezze e dei margini, ecc...

\subsubsection{Versioni del CSS}
Il comitato W3C ha pubblicato la raccomandazione di CSS livello 1 nel 1996.
Un'anno dopo è arrivata la raccomandazione di livello 2, nota semplicemente come CSS2.
Una versione aggiornata della raccomandazione di livello 2, la CSS2.1, fu pubblicata dopo circa dieci anni di lavoro, nel 2011.
Nel frattempo, la W3C stava lavorando anche ad una versione completamente diversa, la CSS3.

Alcune funzionalità della CSS3 sono entrate a far parte della raccomandazione W3C:
\begin{itemize}
	\item Selettori;
	\item Namespace;
	\item Media query;
	\item Colori;
	\item Attributi di stile.
\end{itemize}

\subsubsection{Sintassi del CSS}
Un documento CSS consiste di una o più \textbf{regole} di stile.
Una regola consiste in un selettore che identifica l'elemento o lgi elementi HTML interessati, seguita da una serie di dichiarazioni di coppie proprietà - valore. Ad esempio:

\begin{lstlisting}[language=css, style=codestyle]	
selector { 
	property: value; 
	property2: value; 
}
\end{lstlisting}

Ogni lista di dichiarazioni si chiama anche \textbf{blocco} di dichiarazioni.
Lo whitespace è ignorato, l'unica cosa importante sono i punti e virgola.

\subsubsection{Commenti in CSS}
Si possono inserire commenti nella forma classica: \lstinline|/* Questo e' un commento */|.

\subsection{Selettori}
Quando si definiscono regole CSS, dobbiamo prima usare un selettore per indicare quali elementi verranno effettati.
I selettori CSS possono riferirsi a:
\begin{itemize}
	\item Elementi singoli;
	\item Elementi multipli;
	\item Elementi accoppiati in qualche modo;
	\item Elementi che sono posizionati in un modo specifico nella gerarchia.
\end{itemize}

\subsubsection{Selettori di elemento}
Usano il nome dell'elemento HTML.
Esiste un selettore universale, indicato dal carattere asterisco.
\subsubsection{Selettori raggruppati}
Si possono raggruppare i selettori, usando le virgole:
\begin{lstlisting}[language=css, style=codestyle]	
p, div, aside { 
	margin: 0;
	padding: 0;
}
\end{lstlisting}
Questo è un buon modo per ridurre le dimensioni dei file CSS (elementi con le solite proprietà possono essere ragguppati).

Spesso si usano i selettori raggruppati per annullare gli stili di default del browser, in modo da ridurre inconsistenze date dalla visualizzazione su software diversi.

\subsubsection{Selettori di classe}
Esiste un'attributo HTML, il \lstinline|class|, che permette di specificare classi per elementi di tipo uguale o diverso.
Tutti gli elementi di una solita classe possono essere selezionati in CSS, usando semplicemente un punto seguito dal nome della classe.

Poniamo di avere dell'HTML:
\begin{lstlisting}[language=html, style=codestyle]	
<h1 class="first">Primo</h1>
<p class="first">Sottotitolo</p>
...
\end{lstlisting}

Potremo stilizzare sia l'header che il paragrafo con il CSS:
\begin{lstlisting}[language=css, style=codestyle]	
.first {
	font-style: italic;
	color: red;
}
\end{lstlisting}

\subsubsection{Selettori di ID}
Un selettore di id permette di indicare un'elemento specifico, attraverso l'attributo \lstinline|id|, usando un cancelletto seguito dall'id dell'elemento:

Poniamo di avere dell'HTML:
\begin{lstlisting}[language=html, style=codestyle]	
<h1 id="second">Primo</h1>
\end{lstlisting}

Potremo stilizzare l'header con il CSS:
\begin{lstlisting}[language=css, style=codestyle]	
#second {
	font-style: italic;
	color: red;
}
\end{lstlisting}

\par\medskip 

La differenza fra i selettori di classe e i selettori di id è che i secondi dovrebbero essere usati solo per riferirsi ad un \textbf{unico} elemento, mentre i primi vanno bene per un numero qualsiasi di elementi.
Inoltre, come vedremo in seguito, la specificità dei selettori di id è maggiore di quella dei selettori di classe.

\subsubsection{Selettori di attributo}
Si possono selezionare elementi in base alla presenza o meno di determinati attributi all'interno di elementi, o di valori specifici dati ad attributi di determinati elementi. Per questo si usano le parentesi quadre:
\begin{lstlisting}[language=css, style=codestyle]	
[title] {
	cursor: help;
}
\end{lstlisting}
Questo codice significa che ogni elemento con l'attributo title mostrerà un cursore col simbolo del punto interrogativo (o qualsiasi sia lo stile definito dal sistema operativo per \lstinline|help|).

Esistono, in verità, modi più sofisticati di selezionare su attributi:

\begin{itemize}
	\item \lstinline|[attribute]|: cerca elementi con un attributo specifico;
	\item \lstinline|[attribute=value]|: cerca elementi con un attributo specifico impostato ad un certo valore;
	\item \lstinline|attribute~=value1, value2|: cerca elementi con un attributo specifico impostato ad almeno uno dei valori definiti in una lista separata da virgole;
	\item \lstinline|attribute^=value|: cerca elementi con un attributo specifico il cui valore inizia col valore specificato;
	\item \lstinline|attribute*=value|: cerca elementi con un attributo specifico il cui valore contiene la stringa specificata;
	\item \lstinline|attribute$=value|: cerca elementi con un attributo specifico il cui valore finisce col valore specificato.
\end{itemize}

\subsubsection{Pseudo-selettori}
Un selettore di pseudo-elemento è un modo di selezionare qualcosa che non esiste esplicitamente come un elemento nel documento HTML ma che rappresenta comunque un oggetto selezionabile.
I selettori di pseudo-elemento cominciano con una coppia di due punti, anche se a volte va bene un singolo due punti. 

Un selettore di pseudo-classe si applica ad un elemento HTML esistente, ma lo indirizza quando si trova in un certo stato, o in una certa relazione familiare.

Alcuni esempi sono:
\begin{itemize}
	\item \textbf{Pseudo-classe:}
		\begin{itemize}
			\item \lstinline|a:link|: si applica a link non visitati;
			\item \lstinline|a:visited|: si applica a link visitati;
			\item \lstinline|:focus|: si applica all'elemento che attualmente ha focus;
			\item \lstinline|:hover| si applica all'elemento su cui sto facendo hover;
			\item \lstinline|:active|: si applica all'elemento attivo (e.g. un bottone cliccato);
			\item \lstinline|:checked|: si applica a elementi attivati, come i radio button;
			\item \lstinline|:first-child|: si applica al primo figlio di un'elemento.
		\end{itemize}
	\item \textbf{Pseudo-elemento:}
		\begin{itemize}
			\item \lstinline|::first-letter|: si applica alla prima lettera di un elemento;
			\item \lstinline|::first-line|: si applica alla prima linea di un elemento;
			\item \lstinline|::before|: inserisce contenuti prima di un elemento;
			\item \lstinline|::after|: inserisce contenuti dopo un elemento.
		\end{itemize}
\end{itemize}

\subsubsection{Selettori contestuali}
I selettori contestuali sono selettori di pseudo-classe che permettono di selezionare elementi basandosi sui suoi antenati, discendenti, o fratelli, ergo sulla base della loro relazione gerarchica con altri elementi nell'albero del documento.

Questi sono:
\begin{itemize}
	\item \textbf{Discendente:} indica un elemento che è contenuto da qualche parte dentro un altro elemento.
		Ad esempio: \lstinline|div p| seleziona un paragrafo dentro una div;
	\item \textbf{Figlio:} indica un'elemento specifico che è figlio diretto dell'elemento specificato.
		Ad esempio: \lstinline|div>h2| seleziona un header (di peso 2) figlio diretto di una div;
	\item \textbf{Fratello adiacente:} indica un elemento che è il prossimo fratello (direttamente dopo) dell'elemento specificato.
		Ad esempio: \lstinline|h3+p| seleziona il primo paragrafo dopo qualsiasi heading (di peso 3).
	\item \textbf{Fratello generale:} indica un qualsiasi elemento che condivide il genitore con l'elemento specificato.
		Ad esempio: \lstinline|h3~p|: indica un qualsiasi paragrafo che condivide il genitore con un heading (di peso 3).
\end{itemize}

Un caso particolare è rappresentato dai selettori di tipo discendente, in quanto sono i più usati.
Questi selezionano elementi contenuti da altri elementi, e si specificano usando il carattere spazio.
Possono anche includere ulteriori informazioni sul tipo di discendenza dell'elemento, come ad esempio l'essere primi figli:
\begin{lstlisting}[language=css, style=codestyle]	
#main div p:first-child { ... }
\end{lstlisting}

\subsection{Proprietà}

Ogni dichiarazione in CSS deve contenere una proprietà (ce ne sono centinaia).
I nomi delle proprietà sono definiti dallo standard.

Vediamone alcuni esempi:

\begin{itemize}
	\item \textbf{Font:}
		\begin{itemize}
			\item \lstinline|font|;
			\item \lstinline|font-family|;
			\item \lstinline|font-size|;
			\item \lstinline|font-style|;
			\item \lstinline|font-weight|;
			\item \lstinline|@font-face|.
		\end{itemize}
	\item \textbf{Testo:}
		\begin{itemize}
			\item \lstinline|letter-spacing|;
			\item \lstinline|line-height|;
			\item \lstinline|text-align|;
			\item \lstinline|text-decoration|;
			\item \lstinline|text-indent|.
		\end{itemize}
	\item \textbf{Colori e sfondo:}
		\begin{itemize}
			\item \lstinline|background|;
			\item \lstinline|background-color|;
			\item \lstinline|background-image|;
			\item \lstinline|background-position|;
			\item \lstinline|background-repeat|;
			\item \lstinline|box-shadow|;
			\item \lstinline|color|;
			\item \lstinline|opacity|.
		\end{itemize}
	\item \textbf{Bordi:}
		\begin{itemize}
			\item \lstinline|border|;
			\item \lstinline|border-color|;
			\item \lstinline|border-width|;
			\item \lstinline|border-style|;
			\item \lstinline|border-top|, \lstinline|border-left|, \lstinline|border-right|, \lstinline|border-bottom|;
			\item \lstinline|border-image|;
			\item \lstinline|border-radius|.
		\end{itemize}
	\item \textbf{Spaziature:}
		\begin{itemize}
			\item \lstinline|padding|;
			\item \lstinline|padding-bottom|, \lstinline|padding-left|, \lstinline|padding-right|, \lstinline|padding-bottom|;
			\item \lstinline|margin|;
			\item \lstinline|margin-bottom|, \lstinline|margin-left|, \lstinline|margin-right|, \lstinline|margin-bottom|;
		\end{itemize}
	\item \textbf{Dimensioni:}
		\begin{itemize}
			\item \lstinline|height|;
			\item \lstinline|max-height|;
			\item \lstinline|min-height|;
			\item \lstinline|width|;
			\item \lstinline|max-width|;
			\item \lstinline|min-width|;
		\end{itemize}
	\item \textbf{Layout:}
		\begin{itemize}
			\item \lstinline|bottom|, \lstinline|left|, \lstinline|right|, \lstinline|top|;
			\item \lstinline|clear|;
			\item \lstinline|display|;
			\item \lstinline|float|;
			\item \lstinline|overflow|;
			\item \lstinline|position|;
			\item \lstinline|visibility|;
			\item \lstinline|z-index|.
		\end{itemize}
	\item \textbf{Liste:}
		\begin{itemize}
			\item \lstinline|list-style|;
			\item \lstinline|list-style-image|;
			\item \lstinline|list-style-type|.
		\end{itemize}
	\item \textbf{Effects:}
		\begin{itemize}
			\item \lstinline|animation|;
			\item \lstinline|filter|;
			\item \lstinline|perspective|;
			\item \lstinline|transform|;
			\item \lstinline|transition|.
		\end{itemize}
\end{itemize}

\subsection{Valori}
Ogni dichiarazione deve contenere poi un valore per ogni properietà.
Alcuni valori di proprietà vengono da una lista predefinita di parole chiave.
Altri sono valori come lunghezze, percentuali, numeri puri, colori od URL.

Vediamoli nel dettaglio:

\subsubsection{Colori}
Esistono più modi di esprimere il colore in CSS:
\begin{itemize}
	\item \textbf{Nome:} riferendosi per nome ai colori cercati, ad esempio \lstinline|red|, \lstinline|lightblue|, \lstinline|hotpink| (solo CSS3), ecc...
	\item \textbf{RGB:} si puo indicare il colore in modalità RGB (Rosso, Verde e Blu) come \lstinline|rgb(255,255,255)|. Inoltre, si può usare un quarto attributo \textit{alpha}, che rappresenta la trasparenza del colore, in forma \lstinline|rgb(255,255,255,0)|.
	\item \textbf{HSL:} si può indicare il colore anche in modalità HSL (Hue, Saturation, Lightness (sarebbe Value)) come \lstinline|hsl(255,255,255)|. Anche qui è supportato l'attributo \textit{alpha}.
	\item \textbf{Esadecimale:} infine, si possono indicare i colori in modalità RGB con caratteri esadecimali, ad esempio \lstinline|#FFFFFF|.
\end{itemize}

\subsubsection{Unità di misura}
Si possono usare \textbf{unità relative}, cioè basate sul valore  di qualcos'altro, come la dimensione di un genitore; e \textbf{unità assolute}, cioè basate su unità di misura reali.

Esempi di unità relative sono:

\begin{itemize}
	\item \lstinline|em|: uguali al valore della proprietà \lstinline|font-size| dell'elemento su cui è usato.
		Quindi, quando si usa per le dimensioni dei font, l'unità \lstinline|em| dipende dalle dimensioni del font del genitore;
	\item \lstinline|%|: una misura relativa, in percentuale, alle dimensioni dell'elemento su cui viene usata;
	\item \lstinline|ex|: simile all'em, ma si basa sull'altezza x del font;
	\item \lstinline|ch|: ancora simile all'em, ma si basa sulla dimensione del carattere 0;
	\item \lstinline|rem|: sta per \textit{root em}, che è la dimensione di font dell'elemento radice;
		A differenza di \lstinline|em|, che potrebbe variare fra elementi, \lstinline|rem| è assoluto nella pagina;
	\item \lstinline|vw|, \lstinline|vh|: stanno per \textit{viewport width} e \textit{viewport height}, cioè le dimensioni della finestra dove viene visualizzata la pagina.
		Sono entrambe misure percentuali, e possono essere usate per creare elementi che scalano insieme alla pagina.
\end{itemize}

Ed esempi di unità assolute sono:

\begin{itemize}
	\item \lstinline|in|: pollici;
	\item \lstinline|cm|: centimetri;
	\item \lstinline|mm|: millimetri;
	\item \lstinline|pt|: points, è la misura predefinita di \lstinline|font-size|, e vale $1 \over 72$ pollici;
	\item \lstinline|pc|: pica, vale $1 \over 6$ pollici;
	\item \lstinline|px|: pixel, vale $1 \over 96$ pollici.
\end{itemize}

\subsection{Tipi di stylesheet}
Uno stylesheet è un file CSS che viene applicato ad una pagina web.
Esistono più tipi di stylesheet:
\begin{itemize}
	\item \textbf{Stylesheet d'autore:} creati da zero per un certo sito o una certa pagina; 
	\item \textbf{Stylesheet utente:} creati dagli utenti (o dagli sviluppatori dei browser), solitamente per motivi di accessibilità;
	\item \textbf{Stylesheet del browser:} forniti insieme al browser per visualizzare pagine senza CSS.
\end{itemize}

Inoltre, possiamo (come già visto) mettere il CSS in più posizioni all'interno del codice.
Vediamole nel dettaglio:
\begin{itemize}
	\item \textbf{Stili inline:} sono regole di stile inserite direttamente dentro un'elemento HTML attraverso l'attributo style:
\begin{lstlisting}[language=html, style=codestyle]	
<h2 style="font-size: 24pt">Questo e' un grande titolo</h2>
<h2 style="font-size: 24pt; font-weight: bold">Questo e' un grandissimo titolo</h2>
\end{lstlisting}
Solitamente, conviene evitare di usare questo attributo, in quanto esistono modi migliori e più mantenibili per stilizzare gli elementi;

	\item \textbf{Stili embedded:} sono regole di stili incluse nell'elemento \lstinline|style|, all'interno dell'head.
\begin{lstlisting}[language=html, style=codestyle]	
<head lang="en">
<title>La mia pagina</title>
	...
<style>
h2 {
	font-size: 24pt; 
	font-weight
}
</style>
</head>
\end{lstlisting}
Rappresentano un'approccio migliore degli stili inline, ma sono comunque poco raccomandati in confronto all'opzione successiva;
	\item \textbf{Stili esterni:} sono file CSS esterni inclusi come riferimento nel documento HTML attraverso l'elemento \lstinline|link|. Rappresentano l'opzione più mantenibile (lo stesso stylesheet può stilizzare più pagine, ergo aggiornare lo stylesheet significa aggiornare tutte le pagine), e più veloce (il browser deve fare una sola richiesta HTTP dello stylesheet per tutte le pagine del sito).
\end{itemize}

\subsection{La cascata}
CSS sta per \textit{Cascading} Style Sheet. Cascading, in questo contesto, si riferisce al modo in cui si discriminano le regole da scegliere in caso di conflitti. Questo è necessario in quanto, come abbiamo appena visto, esistono più tipi di stylesheet che spesso si vanno a sovrapporre.

CSS usa i seguenti principi per la sua cascata:
\begin{itemize} 
		\item \textbf{Ereditarietà};
		\item \textbf{Specificità};
		\item \textbf{Posizione}.
\end{itemize}

Vediamoli nel dettaglio.

\subsubsection{Ereditarietà}
Molte (ma non tutte) le proprietà CSS si riferiscono non solo a loro stesse, ma anche ai loro discenedenti.
Font, colori, properità di lista e testo sono ereditabili.
Layout, dimensioni, bordi, sfondi e spaziature non lo sono di default, ma lo possono diventare attraverso la parola chiave \lstinline|inherit| usata per specificare il valore della properità in un elemento discendente.

Ad esempio, potremo avere:
\begin{lstlisting}[language=css, style=codestyle]	
div {
	font-weight: bold;
	margin: 50px;
	border: 1pt solid green;
}
p {
	border: inherit;
	margin: inherit;
}
\end{lstlisting}

In questo caso, un \lstinline|p| dentro un \lstinline|div| avrà bordo e margini ereditati da quest'ultimo.

\subsubsection{Specificità}
La specificità determina quali regole hanno precedenza se applicabili allo stesso elemento.
Più un selettore è specifico, più alta è la precedenza della regola che lo usa.

Questo è implementato con un sistema di \textbf{pesi}, dove diversi selettori hanno diversi pesi (ad esempio un selettore di id è più specifico di un selettore di classe, che a sua volta è più specifico di un selettore di elemento, ecc...) sulla specificità della regola.

La specificità viene calcolata come un numero concatenato $abcd$, dove $a$, $b$, $c$ e $d$ sono cifre.
Le cifre si assegnano come segue:

\begin{itemize}
	\item $a$: vale 1 se il CSS è inline a dell'HTML, 0 altrimenti;
	\item $b$: conta il numero di attributi id del selettore;
	\item $c$: conta il numero di altri attributi e pseudo-classi del selettore;
	\item $d$: conta il numero di elementi e pseudo-elementi del selettore.
\end{itemize}

\subsubsection{Posizione}
Esiste infine un'altro aspetto da considerare, cioè quello della posizione della regola.
Il principio della posizione è che quando le regole hanno la stessa specificità, le ultime hanno più peso.
Questo vale sia per le regole, sia per i blocchi di dichiarazioni.

Esiste un'eccezione a questa regola: il marchio \lstinline|!important| fara in modo che la regola a cui è applicato sovrascriverà ogni altra regola definita dall'autore in altre posizioni.

\subsection{Modello a scatola}
Veniamo quindi a quello che è effettivamente il meccanismo secondo cui vengono disposti gli elementi sulla pagina.
In HTML, tutti gli elementi esistono dentro una \textbf{scatola}.
La scatola ha \lstinline|width| e \lstinline|height|, cioè larghezza e altezza, un \lstinline|padding|, cioè dell'area in più \textit{interna} alla scatola, un \lstinline|margin|, cioè un'area di margine \textit{esterna} alla scatola, è un bordo detto \lstinline|border|.

Il contenuto dell'elemento stà all'interno della scatola, fino al padding.
Lo sfondo del padding è il \lstinline|background-color| o la \lstinline|background-image| dell'elemento, mentre lo sfondo del margine è il \lstinline|background-color| o la \lstinline|background-image| del genitore dell'elemento.

\begin{center}
	\begin{tikzpicture}
	
		\draw[thick] (-2,-2) rectangle(6,4);
		\node at (2, 3.7) {\textsf{Margine}};

		\draw[thick, fill=blue!10] (-1,-1) rectangle(5,3);
		\node at (2, 2.4) {\textsf{Padding}};

		\node at (2, 3.2) {\textsf{Bordo}};
		
		\fill[blue!20] (0,0) rectangle (4,2);
		\node at (2,1) {\textsf{Contenuto}};
		
	\end{tikzpicture}
\end{center}

\subsubsection{Sfondi}
Oggi gli sfondi degli elementi, o \textit{background}, vengono realizzati con apposite proprietà CSS, e non con il tag \lstinline|<img>|.

Vediamo quali sono queste proprietà:
\begin{itemize}
	\item \lstinline|background|: una proprietà combinata che permette di impostare più valori del background contestualmente, imposta comunque a valori di default gli attributi non specificati;
	\item \lstinline|background-attachement|: specifica se l'immagine di sfondo scorre col documento (comportamento di default) o rimane fissa. I valori possibili sono quindi \lstinline|fixed| o \lstinline|scroll|;
	\item \lstinline|background-color|: specifica il colore dello sfondo;
	\item \lstinline|background-image|: specifica l'immagine di sfondo attraverso un URL;
	\item \lstinline|background-position|: specifica dove l'immagine dovrebbe essere posta: ha possibili valori \lstinline|top|, \lstinline|bottom|, \lstinline|center|, \lstinline|left| e \lstinline|right|.
		Si possono anche fornire posizioni in pixel o in percentuali, sempre per entrambe le dimensioni, che indicano la distanza dall'angolo in alto a sinistra dell'elemento;
	\item \lstinline|background-repeat|: determina la ripetizione del background, che può essere \lstinline|repeat|, \lstinline|repeat-x|, \lstinline|repeat-y| e \lstinline|no-repeat|.
	\item \lstinline|background-size|: specifica la dimensione dell'immagine di sfondo.
\end{itemize}

\subsubsection{Bordi}
I bordi possono vengono usati per separare gli elementi fra di loro.
Hanno le seguenti proprietà:
\begin{itemize}
	\item \lstinline|border|: una proprietà combinata che permette di impostare più valori del bordo contestualmente, imposta comunque a valori di default gli attributi non specificati;
	\item \lstinline|border-style|: specfica il tipo di bordo. Sono supportati, fra l'altro, \lstinline|solid|, \lstinline|dotted|, \lstinline|dashed|, \lstinline|double|, \lstinline|groove|, \lstinline|ridge|, \lstinline|inset| e \lstinline|outset|.
	\item \lstinline|border-width|: specifica la larghezza del ordo in unità (ma non in percentuali).
		Sono supportate anche le parole chiave \lstinline|thin|, \lstinline|medium|, ecc...
	\item \lstinline|border-color|: specifica il colore del bordo;
	\item \lstinline|border-radius|: specifica il raggio delle smussature degli spigoli;
	\item \lstinline|border-image|: specifica l'URL di un'immagine da usare come bordo.
\end{itemize}

Si possono indicare questi attributi su un solo lato del bordo usando notazioni come \lstinline|border-top-color|.
Esiste anche una nozione più veloce, che permette di impostare le properietà di ogni lato con una sola dichiarazione, assumendo l'ordinamento \lstinline|top|, \lstinline|right|, \lstinline|bottom| e \lstinline|left| per i lati.
Quindi, ad esempio, si potrà avere:
\begin{lstlisting}[language=css, style=codestyle]	
border-color: red green orange blue;
/* equivale a: */
border-top-color: red;
border-right-color: green;
border-bottom-color: orange;
border-left-color: blue;
\end{lstlisting}

Infine, si ricorda che i bordi vengono allargati dal padding, ma non dai margini.

\subsubsection{Margini e padding}
I margini indicano la dimensione dello spazio lasciato \textbf{esternamente} alla scatola, mentre il padding indica la dimensione lasciata \textbf{internamente} alla scatola.
Si nota che i margini possono \textbf{collassare}: quando abbiamo margini adiacenti verticali, viene usato il valore del margine più grande, e l'altro viene annullato.
I margini orizzontali invece non collassano mai, ed esistono alcuni casi particolari quando nemmeno i verticali lo fanno (il piacere di scoprirli è lasciato al lettore).

\subsubsection{Dimensioni}
Avevamo le proprietà \lstinline|width| e \lstinline|height| per impostare le dimensioni.
Queste non sono del tutto veritiere, in quanto la dimensione degli elementi dipende anche dai loro contenuti.
Per gestire questa situazione, si hanno a disposizione la proprietà \lstinline|overflow|, che indica come gestire la dimensione in eccesso: 
\begin{itemize}
	\item \lstinline|visible|: lascia i contenuti in eccesso visibili:
	\item \lstinline|hidden|: nasconde i contenuti in eccesso (si comporta quasi come una maschera);
	\item \lstinline|scroll|: visualizza scrollbar per permettere di visualizzare tutti i contenuti nel fattore forma indicato da \lstinline|width| e \lstinline|height|;
	\item \lstinline|auto|: lascia scegliere al browser (spesso creera una scroll verticale).
\end{itemize}

\subsection{Stilizzazione del testo}
Esistono due tipi di proprietà che influenzano il testo:
\begin{itemize}
	\item \textbf{Proprietà dei font} che influenzano i font e il loro aspetto;
	\item \textbf{Proprietà di paragrafo} che influenzano il testo a discapito del font usato.
\end{itemize}

Bisogna notare che i font usati dal browser devono essere installati sul computer dell'utente: questo significa che i font installati sulla macchina dello sviluppatore potrebbero non trovarsi su quella degli utenti, e dare così problemi di compatibilità.
Per questo motivo, solitamente si fornisce uno \textbf{web font stack}, cioè una lista di font alternativi da usare nel caso non si trovasse la scelta originale sul computer dell'utente.

Vediamo quindi tutte le proprietà dei font:
\begin{itemize}
	\item \lstinline|font|: una proprietà combinata che permette di impostare più valori del bordo contestualmente, imposta comunque a valori di default gli attributi non specificati;
	\item \lstinline|font-family|: specifica quale font usare. Come già detto se ne possono (e se ne dovrebbero) specificare più di uno;
	\item \lstinline|font-size|: specifica la dimensione del font in punti;
		\lstinline|font-style|: specifica se il font è in corsivo, grassetto, ecc...
	\item \lstinline|font-variant|: specifica la variante del font, ad esempio se è in stampatello minuscolo o no;
	\item \lstinline|font-weight|: specifica il peso del font, con un valore da 100 a 900 in multipli di 100, o con una parola chiave fra \lstinline|normal|, \lstinline|bold|, \lstinline|bolder| e \lstinline|lighter|.
\end{itemize}
e del paragrafo:
\begin{itemize}
	\item \lstinline|letter-spacing|: specifica la spaziatura fra le lettere;
	\item \lstinline|line-height|: specifica l'altezza di una linea di testo;
	\item \lstinline|text-align|: specifica l'allineamento del testo;
	\item \lstinline|text-decoration|: specifica le decorazioni (sottolineatura, sopralineatura, ecc...);
	\item \lstinline|text-direction|: specifica la direzione del testo;
	\item \lstinline|text-shadow|: imposta un'effetto di ombreggiatura, specificando gli offset orizzontali e verticali, la sfocatura e il colore dell'ombra.
\end{itemize}

\subsubsection{Font-face}
Il selettore \lstinline|@font-face| permette di usare font non scaricati sulla macchina dell'utente, appoggiandosi a siti open source come Google Web Fonts.

\subsubsection{Nota sulle unità di misura}
Usare i pixel non è particolarmente sicuro: la densità dei pixel dei dispositivi moderni è variata in modo che un pixel CSS non corrisponde più tanto spesso a un pixel effettivo sul dispositivo.
Se vogliamo creare layout che funzionino bene su più dispositivi, dobbiamo usare unità come gli \lstinline|em| e le percentuali.
Usare queste unità implica anche che l'utente potrà, a piacimento, cambiare la dimensione del testo.
Ricordiamo poi l'unità \lstinline|rem|, che si basa sull'origine del documento, ed è quindi sempre uguale in esso.

\lstset{language=html, style=codestyle}

\subsection{Tabelle HTML}
Il linguaggio HTML ci permette di creare tabelle attraverso il tag \lstinline|table|.
Queste possono visualizzare una vasta gamma di contenuti, dalle immagini al testo, ai link e altre tabelle.

\subsubsection{Struttura di una tabella}
Una \lstinline|table| contiene un certo numero di righe indicate da \lstinline|tr|, e ogni riga contiene un certo numero di celle \lstinline|td|. I contenuti vanno sempre dentro le celle.
I titoli delle colonne si scrivono nei tag \lstinline|th| anziché \lstinline|td|.
Ad esempio, potremmo avere:

\begin{lstlisting}[language=html, style=codestyle]	
<table>
	<tr>
		<th>Sintetizzatore</th>
		<th>Produttore</th>
		<th>Anno</th>
	</tr>
	<tr>
		<td>Roland TB-303</td>
		<td>Roland</td>
		<td>1981</td>
	</tr>
	<tr>
		<td>Yamaha DX7</td>
		<td>Yamaha</td>
		<td>1983</td>
	</tr>
	<tr>
		<td>ARP Odyssey</td>
		<td>ARP</td>
		<td>1972</td>
	</tr>
	<tr>
		<td>Sequential Prophet-5</td>
		<td>Sequential Circuits</td>
		<td>1978</td>
	</tr>
</table>
\end{lstlisting}

\subsubsection{Celle non standard}
Se vogliamo che una cella occupi più colonne, usiamo l'attributo \lstinline|colspan|.
Ad esempio:
\begin{lstlisting}[language=html, style=codestyle]	
<table>
	<tr>
		<th>Sintetizzatore</th>
		<th colspan=2>Anno e produttore</th>
	</tr>
	...
</table>
\end{lstlisting}

Allo stesso modo, se vogliamo che una cella occupi più righe, usiamo \lstinline|rowspan|.
Ad esempio:

\begin{lstlisting}[language=html, style=codestyle]	
<table>
	<tr>
		<th>Produttore</th>
		<th>Sintetizzatore</th>
	</tr>
	<tr>
		<td rowspan=2>Roland</td>
		<td>MS-20</td>
	</tr>
	<tr>
		/* qui serve un'elemento solo! */
		<td>M1</td>
	</tr>
	<tr>
		<td>ARP Odyssey</td>
		<td>ARP</td>
		<td>1972</td>
	</tr>
	<tr>
		<td>Sequential Prophet-5</td>
		<td>Sequential Circuits</td>
		<td>1978</td>
	</tr>
</table>
\end{lstlisting}

\subsubsection{Elementi addizionali}
Esistono altri elementi da aggiungere alle tabelle:
\begin{itemize}
	\item \lstinline|caption|: indica un titolo per la tabella;
	\item \lstinline|col| e \lstinline|colgroup|: indicano gruppi di colonne;
	\item \lstinline|thead|, \lstinline|tbody| e\lstinline|tfoot|: indicano una separazione semantica fra l'intestazione, il corpo e il footer di una tabella.
\end{itemize}

Le tabelle, in ogni caso, possono poi essere stilizzate come tutti gli elementi HTML attraverso il css.

\end{document}

