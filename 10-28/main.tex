\documentclass[a4paper,11pt]{article}
\usepackage[a4paper, margin=8em]{geometry}

% usa i pacchetti per la scrittura in italiano
\usepackage[french,italian]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\frenchspacing 

% usa i pacchetti per la formattazione matematica
\usepackage{amsmath, amssymb, amsthm, amsfonts}

% usa altri pacchetti
\usepackage{gensymb}
\usepackage{hyperref}
\usepackage{standalone}

% imposta il titolo
\title{Appunti Progettazione Web}
\author{Luca Seggiani}
\date{2024}

% imposta lo stile
% usa helvetica
\usepackage[scaled]{helvet}
% usa palatino
\usepackage{palatino}
% usa un font monospazio guardabile
\usepackage{lmodern}

\renewcommand{\rmdefault}{ppl}
\renewcommand{\sfdefault}{phv}
\renewcommand{\ttdefault}{lmtt}

% disponi il titolo
\makeatletter
\renewcommand{\maketitle} {
	\begin{center} 
		\begin{minipage}[t]{.8\textwidth}
			\textsf{\huge\bfseries \@title} 
		\end{minipage}%
		\begin{minipage}[t]{.2\textwidth}
			\raggedleft \vspace{-1.65em}
			\textsf{\small \@author} \vfill
			\textsf{\small \@date}
		\end{minipage}
		\par
	\end{center}

	\thispagestyle{empty}
	\pagestyle{fancy}
}
\makeatother

% disponi teoremi
\usepackage{tcolorbox}
\newtcolorbox[auto counter, number within=section]{theorem}[2][]{%
	colback=blue!10, 
	colframe=blue!40!black, 
	sharp corners=northwest,
	fonttitle=\sffamily\bfseries, 
	title=Teorema~\thetcbcounter: #2, 
	#1
}

% disponi definizioni
\newtcolorbox[auto counter, number within=section]{definition}[2][]{%
	colback=red!10,
	colframe=red!40!black,
	sharp corners=northwest,
	fonttitle=\sffamily\bfseries,
	title=Definizione~\thetcbcounter: #2,
	#1
}

% disponi codice
\usepackage{listings}
\usepackage[table]{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{codestyle}{
		backgroundcolor=\color{black!5}, 
		commentstyle=\color{codegreen},
		keywordstyle=\bfseries\color{magenta},
		numberstyle=\sffamily\tiny\color{black!60},
		stringstyle=\color{green!50!black},
		basicstyle=\ttfamily\footnotesize,
		breakatwhitespace=false,         
		breaklines=true,                 
		captionpos=b,                    
		keepspaces=true,                 
		numbers=left,                    
		numbersep=5pt,                  
		showspaces=false,                
		showstringspaces=false,
		showtabs=false,                  
		tabsize=2
}

\lstdefinestyle{shellstyle}{
		backgroundcolor=\color{black!5}, 
		basicstyle=\ttfamily\footnotesize\color{black}, 
		commentstyle=\color{black}, 
		keywordstyle=\color{black},
		numberstyle=\color{black!5},
		stringstyle=\color{black}, 
		showspaces=false,
		showstringspaces=false, 
		showtabs=false, 
		tabsize=2, 
		numbers=none, 
		breaklines=true
}

\lstdefinelanguage{css}{
  keywords={text-shadow, text-direction, background-attachement, background-size, font, font-family, font-size, font-style, font-weight, @font-face, letter-spacing, line-height, text-align, text-decoration, text-indent, background, background-color, background-image, background-position, background-repeat, box-shadow, color, opacity, border, border-color, border-width, border-style, border-top, border-left, border-right, border-bottom, border-image, border-radius, padding, padding-bottom, padding-left, padding-right, padding-bottom, margin, margin-bottom, margin-left, margin-right, margin-bottom, height, max-height, min-height, width, max-width, min-width, bottom, left, right, top, clear, display, float, overflow, position, visibility, z-index, list-style, list-style-image, list-style-type, animation, filter, perspective, transform, transition ,a, link, visited, focus, hover, active, checked, first-letter, first-line, before, after, cursor, first-child, font-style,color,background-image:,margin,padding,font,weight,display,position,top,left,right,bottom,list,style,border,size,white,space,min,width, transition:, transform:, transition-property, transition-duration, transition-timing-function},	
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]',
  morestring=[b]",
  alsoletter={:},
  alsodigit={-},
	literate=%
    {:}{{\textcolor{black}{:}}}1,  % Treat ':' as a regular symbol, not part of a keyword
}

\lstdefinelanguage{javascript}{
	keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
	keywordstyle=\color{blue}\bfseries,
	ndkeywords={class, export, boolean, throw, implements, import, this},
	ndkeywordstyle=\color{darkgray}\bfseries,
	identifierstyle=\color{black},
	sensitive=false,
	comment=[l]{//},
	morecomment=[s]{/*}{*/},
	commentstyle=\color{purple}\ttfamily,
	stringstyle=\color{red}\ttfamily,
	morestring=[b]',
	morestring=[b]"
}

% disponi sezioni
\usepackage{titlesec}

\titleformat{\section}
	{\sffamily\Large\bfseries} 
	{\thesection}{1em}{} 
\titleformat{\subsection}
	{\sffamily\large\bfseries}   
	{\thesubsection}{1em}{} 
\titleformat{\subsubsection}
	{\sffamily\normalsize\bfseries} 
	{\thesubsubsection}{1em}{}

% disponi alberi
\usepackage{forest}

\forestset{
	rectstyle/.style={
		for tree={rectangle,draw,font=\large\sffamily}
	},
	roundstyle/.style={
		for tree={circle,draw,font=\large}
	}
}

% disponi numeri di pagina
\usepackage{fancyhdr}
\fancyhf{} 
\fancyfoot[L]{\sffamily{\thepage}}

\makeatletter
\fancyhead[L]{\raisebox{1ex}[0pt][0pt]{\sffamily{\@title \ \@date}}} 
\fancyhead[R]{\raisebox{1ex}[0pt][0pt]{\sffamily{\@author}}}
\makeatother

\begin{document}
% sezione (data)
\section{Lezione del 28-10-24}

% stili pagina
\thispagestyle{empty}
\pagestyle{fancy}

\lstset{language=javascript, style=codestyle}

% testo
\subsection{Il modello a oggetti del documento}
Il Document Object Model (DOM) è un meccanismo che ci permette di modificare dinamicamente i contenuti di una pagina web attraverso linguaggi di scripting come il JavaScript.

Si ha che, sebbene il codice HTML di una pagina sia effettivamente lineare, la struttura che esso va a definire è fondamentalmente \textbf{strutturata}: diversi elementi possono coesistera in relazioni di parentela padre/figlio, fratello/fratello, ecc...
Questo significa che si può rappresentare un documento HTML attraverso una \textbf{struttura ad albero}, dove ogni elemento viene detto \textbf{nodo}.

Le interazioni col DOM avvengono attraverso un oggetto specializzato detto \lstinline|NodeList| (letteralmente, "lista di nodi"), che mantiene appunto, in maniera simile ad un array, un insieme di nodi.
A questo punto, quando si ha accesso al DOM della pagina, modificare un elemento significa trovare il nodo corrispondente in una NodeList, e modificarlo.

\subsubsection{Tipi di nodo}
Esistono, innanzitutto, alcuni tipi principali di nodi nel DOM:
\begin{itemize}
	\item \textbf{Nodi elemento:} rappresentano elementi veri e propri del documento, come \lstinline|div|, \lstinline|a|, \lstinline|p|, ecc...
	\item \textbf{Nodi testo:} rappresentano il testo contenuto in elementi come paragrafi, anchor, ecc...
	\item \textbf{Nodi attributo:} rappresentano attributi di elementi, come \lstinline|class|, \lstinline|id|, \lstinline|src|, ecc...
	\item \textbf{Nodi commento:} rappresentano commenti nella struttura del documento HTML. 
\end{itemize}

\subsubsection{Proprietà fondamentali dei nodi}
Un nodo ha, fra le altre, le seguenti proprietà essenziali:
\begin{itemize}
	\item \lstinline|childNodes|, una \lstinline|NodeList| che contiene i figli del nodo;
	\item \lstinline|firstChild|, il primo nodo figlio del nodo interessato;
	\item \lstinline|lastChild|, come sopra, l'ultimo nodo figlio del nodo interessato;
	\item \lstinline|nextSibling|, il prossimo nodo fratello del nodo corrente, cioè il nodo successivo sul livello corrente;
	\item \lstinline|nodeName|, il nome del nodo, che equivale al nome del tag per i nodi tag, al nome dell'attributo per i nodi attributo, e a \lstinline|#text| per i nodi testo;
	\item \lstinline|nodeValue|, il valore del nodo, cioè Null per nodi elemento, il testo per nodi testo, e il contenuto dei commenti nei nodi commento;
	\item \lstinline|parentNode|: il nodo genitore del nodo corrente;
	\item \lstinline|previousSibling|, il precedente nodo fratello del nodo corrente, cioè il nodo precedente sul livello corrente;
 	\item \lstinline|textContent|, una rappresentazione testuale del nodo, da cui sono stati rimossi i tag.
\end{itemize}

Per quanto riguarda i nodi elemento, si hanno poi le proprietà:
\begin{itemize}
	\item \lstinline|classList|, una lista in sola lettura (con metodi get/set) delle classi CSS assegnate a questo elemento. Le classi, a differenza dello stile, sono da usarsi per la modifica a tempo di esecuzione degli stili, in quanto mantengono più isolate le implementazioni in CSS e in JavaScript, rispettivamente degli stili stessi e della logica che li governa;
	\item \lstinline|className|, il nome della classe a cui appartiene l'elemento;
	\item \lstinline|id|, l'id dell'elemento;
	\item \lstinline|innerHtml|, l'HTML che descrive l'elemento, che può ma \textbf{non dovrebbe} essere modificato (vedi attacchi XSS);
	\item \lstinline|style|, una lista delle proprietà CSS assegnate a questo elemento, che può influenzare effettivamente gli stessi parametri modificati attraverso un cambio di classe con \lstinline|classList|, ma il cui utilizzo è sconsigliato in quanto si vanno a creare proprietà via scripting che non hanno riscontro nel CSS;
	\item \lstinline|tagName|, il nome del tag che forma l'elemento.
\end{itemize}

Alcuni tag hanno poi proprietà aggiuntive:
\begin{itemize}
	\item \lstinline|href|, indica l'URL collegato nei tag \lstinline|a|;
	\item \lstinline|name|, identifica, in maniera simile a \lstinline|id|, elementi. Riguarda principalmente campi dati per form: si può infatti usare per \lstinline|a|, \lstinline|input|, \lstinline|textarea| e \lstinline|form|;
	\item \lstinline|src|, indica l'URL sorgente dei contenuti visualizzati da \lstinline|img|, \lstinline|input|, \lstinline|iframe| e \lstinline|script|;
	\item \lstinline|value|, fornisce il valore di input dato dagli elementi di input, come \lstinline|input|, \lstinline|textarea| e \lstinline|submit|.
\end{itemize}

\subsubsection{Accedere al DOM}
In JavaScript, si può ottenere un riferimento al DOM attraverso l'oggetto \lstinline|document|. 
Questo, oltre al DOM, contiene anche proprietà riguardanti il documento stesso, fra cui l'URL, il tipo di encoding, ecc...

Esistono quindi 3 modi principali per modificare, o comunque interagire, con il DOM:
\begin{itemize}
	\item \textbf{Metodi di selezione}: i metodi di selezione di \lstinline|document| sono, in ordine di selettività decrescente, \lstinline|getElementById(id)|, \lstinline|getElementsByClassName(name)|, e \lstinline|getElementsByTagName(name)|.
	Questi cercano, rispettivamente, i nodi per id, per nome di classe, o per nome di tag.
	
	Esistono poi altri metodi, fra cui ricordiamo \lstinline|querySelector()| e \lstinline|querySelectorAll|, che permettono di ottenere elementi nello stesso modo in cui lo faremmo in CSS, cio+ specificando una stringa di query.
	La differenza fra i due metodi è che \lstinline|querySelector()| restituisce il primo elemento che rispetta la query, e \lstinline|querySelectorAll()| li restituisce tutti;
	\item \textbf{Modificazione strutturale dei nodi}:
esistono diversi metodi per modificare la struttura del DOM:
\begin{itemize}
	\item \lstinline|appendChild|: inserisce un nuovo nodo figlio in fondo al nodo corrente;
	\item \lstinline|createAttribute|: crea un nuovo nodo attributo sul nodo corrente;
	\item \lstinline|createElement|: crea un nodo elemento;
	\item \lstinline|createTextNode|: crea un nodo di testo;
	\item \lstinline|insertAdjacentElement|: crea un nodo figlio in una di quattro posizioni relative al nodo corrente:
		\begin{itemize}
			\item \lstinline|beforebegin|: prima dell'elemento su cui si applica la funzione;
			\item \lstinline|afterbegin|: dentro l'elemento su cui si applica la funzione, come primo figlio;
			\item \lstinline|beforeend|: dentro l'elemento su cui si applica la funzione, come ultimo figlio;
			\item \lstinline|afterend|: dopo l'elemento su cui si applica la funzione.
		\end{itemize}
	\item \lstinline|insertAdjacentText|: come sopra, ma per i nodi testo;
	\item \lstinline|insertBefore|: inserisce un nodo figlio prima di un nodo di riferimento nel nodo corrente;
	\item \lstinline|removeChild|: rimuove un nodo figlio dal nodo corrente;
	\item \lstinline|replaceChild|: rimpiazza un nodo figlio con un figlio diverso. 
\end{itemize}
	\item \textbf{Metodi evento}: il DOM si interfaccia direttamente col gestore di eventi del JavaScript, attraverso il metodo \lstinline|addEventListener()|. La prossima sezione si interessa appunto di quali funzionalità possono essere implementate attraverso questo sistema.
\end{itemize}

\subsubsection{Temporizzazione del DOM}
Il DOM viene caricato al momento di caricamento della pagina. 
Non dovremmo mai cercare di modificare il DOM prima che questo sia stato caricato, ergo bisogna controllare lo stato di caricamento del DOM prima di accedervi per modifiche.
Questo può essere fatto attraverso, come vedremo, il sistema di \textbf{eventi} fornito dal JavaScript.

\subsection{Gestione degli eventi}
In JavaScript è supportato il meccanismo di gestione degli eventi attraverso \textbf{event handler}.
Un event handler viene definito in codice dal programmatore, e poi registrato attraverso la funzione \lstinline|addEventLister| di un elemento DOM.
A questo punto, a tempo di esecuzione, quando l'evento verrà attivato si avrà che l'event handler verrà eseguito.UN esempio di questo sistema è il seguente:
\begin{lstlisting}[language=javascript, style=codestyle]	
function myHandler() {
	alert("Ahi!");
}

const btn = document.querySelector("#btn");
btn.addEventListener("click", myHandler);
\end{lstlisting}
In questo caso, al click del pulsante di classe \lstinline|#btn|, la funzione \lstinline|myHandler()| verrà invocata e visualizzerà un messaggio a schermo.

Spesso, è più conveniente usare funzioni anonime, o una arrow function, come event handler:
\begin{lstlisting}[language=javascript, style=codestyle]	
const btn = document.getElementById("btn");
btn.addEventListener("click", function() {
	alert("Sono una funzione anonima");
});

const btn = document.getElementById("btn");
btn.addEventListener("click", () => {
	alert("Sono una funzione freccia");
});
\end{lstlisting}

\subsubsection{Tipi di evento}
Esistono, oltre al \lstinline|click|, diversi tipi di eventi.
Questi sono:
\begin{itemize}
	\item \textbf{Eventi di mouse}, fra cui:
		\begin{itemize}
			\item \lstinline|click|: visto finora, corrisponde al click del mouse su un elemento;
			\item \lstinline|dbclick|: corrisponde a un doppio click su un elemento;
			\item \lstinline|mousedown|: corrisponde alla prima pressione del mouse su un elemento;
			\item \lstinline|mouseup|: corrisponde al rilascio del mouse sull'elemento;
			\item \lstinline|mouseover|: corrisponde a passare (non necessariamente cliccare) con il mouse sopra un elemento;
			\item \lstinline|mouseout|: corrisponde a rimuovere il mouse da un elemento;
			\item \lstinline|mousemove|: corrisponde a muovere il mouse mentre si trova sopra un elemento.
		\end{itemize}
	\item \textbf{Eventi di tastiera}, fra cui:
		\begin{itemize}
			\item \lstinline|keydown|: corrisponde alla pressione di un tasto da parte dell'utente;
			\item \lstinline|keyup|: corrisponde al rilascio di un tasto da parte dell'utente.
		\end{itemize}
	\item \textbf{Eventi di tocco}, lanciati da interfacce touchscreen, simili agli eventi lanciati dal mouse;
	\item \textbf{Eventi form}, fra cui:
		\begin{itemize}
			\item \lstinline|blur|: lanciato quando quando un elemento di un form perde il focus;
			\item \lstinline|focus|: lanciato quando un elemento di un form ottiene il focus;
			\item \lstinline|change|: lanciato quando una casella di input cambia valore (magari per l'azione dell'utente);
			\item \lstinline|reset|: lanciato al reset del form;
			\item \lstinline|select|: lanciato quando si seleziona del testo;
			\item \lstinline|submit|: lanciato all'invio del form. In particolare, questo evento può essere usato per fare della prevalidazione dei contenuti prima di inviarli al server. Ad esempio:
\begin{lstlisting}[language=javascript, style=codestyle]	
document.querySelector("#loginForm").addEventListener("submit", function(e) {
	let pass = document.querySelector("#pw").value;
	if(pass="") {
		alert("Inserisci una password");
		e.preventDefault(); /* questo impedisce il submit chiamato dall'utente */
	}
});
\end{lstlisting}
		\end{itemize}

	In generale, l'interazione e la validazione coi formi rimane uno degli usi più popolari del JavaScript.
	Possiamo infatti usare lo scripting per rispondere alle seguenti casistiche:
	\begin{itemize}
		\item Movimento fra elementi, di cui possiamo approfittare per dare aiuto contestuale all'utente;
		\item Cambiamento di dati di elementi di input, che possiamo usare per fare prevalidazione o come sopra, per dare aiuto contestuale;
		\item Invio finale del form, prima del quale, come abbiamo visto, possiamo fare delle operazioni di prevalidazione.
			Bisogna notare che qualsiasi prevalidazione si faccia sul lato client andrà rifatta sul lato server, in quanto l'ingresso dal lato client non è mai sicuro (il codice inviato da server può essere stato alterato sulla macchina dell'utente).
			Fare queste validazioni sul lato client resta comunque utile per ridurre il traffico in uscita al server, in quanto in condizoni operative si possono notare errori prima dell'invio dei dati.
	\end{itemize}

	\item \textbf{Eventi media}, relativi a contenuti multimediali, fra cui:
		\begin{itemize}
			\item \lstinline|ended|: lanciato quando dell'audio o del video ha finito di eseguire;
			\item \lstinline|pause|: lanciato quando dell'audio o del video è stato messo in pausa;
			\item \lstinline|play|: lanciato quando dell'audio o del video viene avviato;
			\item \lstinline|ratechange|: lanciato quando la velocità di playback di un contenuto multimediale cambia;
			\item \lstinline|volumechange|: lanciato quando il volume di un contenuto multimediale cambia.
		\end{itemize}
	\item \textbf{Eventi frame}, fra cui:
		\begin{itemize}
			\item \lstinline|abort|: lanciato quando si arresta il caricamento di una risorsa;
			\item \lstinline|error|: lanciato quando il caricamento di una risorsa va in errore;
			\item \lstinline|load|: lanciato quando la finestra è stata caricata completamente;
			\item \lstinline|DOMContentLoaded|: lanciato quando il documento HTML è stato caricato e il DOM è pronto;
			\item \lstinline|orientationchange|: lanciato quando si cambia orientamento (dello schermo);
			\item \lstinline|resize|: lanciato quando si modifica la dimensione del documento;
			\item \lstinline|scroll|: lanciato quando si scrolla il documento;
			\item \lstinline|unload|: lanciato quando il documento viene rimosso dalla memoria, cioè quando l'utente lascia la pagina. 
		\end{itemize}
		Gli eventi frame permettono di implementare tecniche di \textbf{lazy loading}, o \textit{caricamento pigro}, cioè di caricare contenuti non essenziali della pagina (script, immagini, contenuti multimediali) solo quando l'utente compie determinate azioni (come scorrere sulla pagina, spostarsi fra pagine, ecc...).
		Così facendo si riduce la cosiddetta \textbf{critical rendering path}, cioè il numero minimo di risorse che il browser deve scaricare prima di visualizzare la pagina, e quindi il tempo complessivo di accesso alla pagina. 
\end{itemize}

\subsubsection{Caricamento pagina e il DOM}
Possiamo quindi risolvere introdotto due paragrafi fa, cioè quello di capire quando la pagina è caricata.
Questo può essere verificato attraverso due eventi separati:
\begin{itemize}
	\item \lstinline|window.load|: questo evento viene lanciato quando l'intera pagina è caricata (incluse immagini, script e stylesheet). Spesso non è necessario aspettare tanto, in quanto si può semplicemente aspettare il prossimo evento:
	\item \lstinline|document.DOMContentLoaded|: questo evento viene lanciato quando il documento HTML è stato completamente scaricato e interpretato. Basta per iniziare a fare modifiche scriptate sul DOM.
\end{itemize}

Possiamo quindi racchiudere tutto il nostro codice relativo al DOM all'interno di un handler per l'evento \lstinline|DOMContentLoaded|, ad esempio come:
\begin{lstlisting}[language=javascript, style=codestyle]	
document.addEventListener("DOMContentLoaded", function() {
	/* il mio codice */
});
\end{lstlisting}

\subsubsection{Oggetti evento}
Ogni volta che viene lanciato un evento, si va a creare un oggetto relativo a quell'evento, che trasporta informazioni che possono essere raccolte attraverso le proprietà dell'oggetto stesso.
Ad esempio, un'evento \lstinline|click| contiene le proprietà \lstinline|clientX| e \lstinline|clientY|, che rappresentano la posizone del cursore dell'utente al momento del click.

Un'evento viene passato come oggetto alle funzioni event handler che prevedono un argomento. Ad esempio si può avere: 
\begin{lstlisting}[language=javascript, style=codestyle]	
const menu = document.querySelectorAll("#menu li");
for(let item of menu) {
	item.addEventListener("click", menuHandler);
}
function menuHandler(e) {
	/* e contiene un oggetto dell'evento onclick */
	const x = e.clientX;
	const y = e.clientY;
	/* fai qualcosa con la posizione del cursore x, y */
}
\end{lstlisting}

\subsection{Propagazione di eventi}
Quando un'evento viene lanciato su un elemento che ha degli antenati, questo viene propagato sugli antenati.
Per ragioni storiche, la propagazione avviene in due direzioni:
\begin{itemize}
	\item \textbf{Fase di cattura, o \textit{"trickle down"}:} nella fase iniziale, il browser propaga l'evento all'elemento più esterno (quindi il tag \lstinline|html|), e poi via via nei tag interni fino a raggiungere il tag che ha lanciato l'evento in primo luogo. Il browser Netscape ha storicamente adottato questo modello;
	\item \textbf{Fase di bubbling:} nella seconda fase, l'evento viene propagato dall'elemento che lo ha lanciato fino agli elementi esterni. Il browser Explorer ha, di contro, adottato storicamente questo modello.
\end{itemize}

Oggi, i browser supportano entrambe le fasi, che solitamente svolgono esattamente in quest'ordine.
In particolare, si può specificare alla chiamata di \lstinline|addEventListener| quale fase si vuole usare, col valore default di \lstinline|bubble|:
\begin{lstlisting}[language=javascript, style=codestyle]	
/* si crea un event listener per la funzione "funzioneCattura" in fase di cattura */
elem.addEventListener('click', funzioneCattura, true);
/* oppure */
elem.addEventListener('click', funzioneCattura, { capture: true; });
/* si crea un event listener per la funzione "funzioneBolleggia" in fase di bubbling */
elem.addEventListener('click', funzioneBolleggia, false);
/* oppure */
elem.addEventListener('click', funzioneBolleggia, {capture: false; });
/* oppure, visto che e' default */
elem.addEventListener('click', funzioneBolleggia);
\end{lstlisting}

\subsubsection{Fermare la propagazione}

Esiste un problema con questo tipo di propagazione degli eventi: a volte vorremmo che un evento venisse catturato, e che poi non si propagasse oltre nella fasse di bubbling. 
Per fare ciò, possiamo usare il metodo \lstinline|stopPropagation()| in fase di bubbling, sull'oggetto evento ottenuto dall'event handler. Un'esempio è:
\begin{lstlisting}[language=javascript, style=codestyle]	
const btns = document.querySelectorAll(".plus");
for (let b of btns) {
	b.addEventListener("click", function (e) {
		e.stopPropagation();
		incrementCount(e);
	});
}
\end{lstlisting}

\subsection{Delegazione di eventi}
Il meccanismo di propagazione può semplificare la gestione degli eventi nel caso si abbiano più elementi che possono lanciare eventi che devono essere gestiti da un singolo event handler.
In questo caso, anziché definire l'event handler su tutti gli elementi, come avevamo fatto nell'esempio precedente:
\begin{lstlisting}[language=javascript, style=codestyle]	
const btns = document.querySelectorAll(".plus");
/* li scorro tutti */
for (let b of btns) {
	b.addEventListener("click", function (e) { /* handler */ });
}
\end{lstlisting}

si può definire un singolo event handler su un elemento genitore a tutti gli elementi lanciatori di eventi.
In questo caso, attraverso la propagazione in fase di bubbling, si ha che l'evento viene catturato da questo genitore indefferentemente da quale elemento sia a lanciarlo:
\begin{lstlisting}[language=javascript, style=codestyle]	
const parent = document.querySelector("#list");
parent.addEventListener("click", function (e) {
	if(e.target && e.target.nodeName == "BUTTON") {
		/* handler*/
	}
});
\end{lstlisting}

\subsection{Dataset}
Esiste una differenza di temporizzazione fra le variabili dichiarate nel codice HTML (e quindi ottenute dal DOM) e quelle dichiarate nel codice JavaScript di un event handler: a tempo di definizione, quest'ultimo non avrà accesso al DOM, e quindi a parametri specifici all'HTML.
Per ovviare a questo problema si usano la proprietà \lstinline|dataset|, e quindi gli attributi \lstinline|dataset| nei tag HTML: questi sono particolari attributi, prefissi da \lstinline|data-|, che permettono di inserire informazioni qualsiasi in un elemento HTML.
Ad esempio, si potrà avere:
\begin{lstlisting}[language=html, style=codestyle]	
<img src="file.png" id="a", data-country="Mozambico">
\end{lstlisting}
in HTML, e:
\begin{lstlisting}[language=javascript, style=codestyle]	
const element = document.getElementById("a");
const country = element.dataset.country;
/* adesso hai "Mozambico" in country */
\end{lstlisting}
per accedervi in JavaScript.

\end{document}
